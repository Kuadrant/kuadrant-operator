name: Verify Dashboards and Alerts OK

on: 
  push:
    # paths:
    #   # Dashboards
    #   - examples/dashboards/app_developer.json
    #   - examples/dashboards/business_user.json
    #   - examples/dashboards/platform_engineer.json
    #   # Alerts
    #   - examples/alerts/prometheusrules_policies_missing.yaml
    #   - examples/alerts/slo-availability.yaml
    #   - examples/alerts/slo-latency.yaml
jobs:
  deploy-register-self-runner:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - uses: hashicorp/setup-terraform@v3

      - name: Initialize Terraform Environment
        run: terraform init

      - name: Create PEM files
        run: |
          echo "${{ secrets.AWS_PEM_KEY }}" > ${{ secrets.AWS_KEY_NAME }}.pem
          echo "${{ secrets.APP_PRIVATE_KEY }}" > app_private.pem
          chmod 400 ${{ secrets.AWS_KEY_NAME }}.pem app_private.pem

      - name: Apply Terraform Configuration + Extract Public IP
        run: |
          terraform apply -auto-approve -var=aws_access_key=${{ secrets.AWS_ACCESS_KEY_ID }} -var=aws_secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }} -var=aws_key_name=${{ secrets.AWS_KEY_NAME }}
          # Get the public IP address of the instance
          echo "EC2_PUBLIC_IP=$(terraform output instance_public_ip)" >> $GITHUB_ENV

      - name: Upload statefile for use further down
        uses: actions/upload-artifact@v4
        with:
          name: terraform-tfstate
          path: terraform.tfstate

      - name: Generate a JWT Token
        run: |
          #!/usr/bin/env bash

          set -o pipefail

          client_id=${{ var.APP_ID }} # Client ID as first argument

          pem=$( cat app_private.pem ) # file path of the private key as second argument

          now=$(date +%s)
          iat=$((${now} - 60)) # Issues 60 seconds in the past
          exp=$((${now} + 600)) # Expires 10 minutes in the future

          b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

          header_json='{
              "typ":"JWT",
              "alg":"RS256"
          }'
          # Header encode
          header=$( echo -n "${header_json}" | b64enc )

          payload_json='{
              "iat":'"${iat}"',
              "exp":'"${exp}"',
              "iss":'"${client_id}"'
          }'
          # Payload encode
          payload=$( echo -n "${payload_json}" | b64enc )

          # Signature
          header_payload="${header}"."${payload}"
          signature=$(
              openssl dgst -sha256 -sign <(echo -n "${pem}") \
              <(echo -n "${header_payload}") | b64enc
          )

          # Create JWT
          JWT="${header_payload}"."${signature}"

          # echo to variable for later use
          echo $JWT_TOKEN >> $GITHUB_ENV


      - name: Generate Registration Token
        run: |
          REPO_OWNER=${{ github.repository_owner }}
          REPO_NAME=${{ github.event.repository.name }}
          RESPONSE=$(curl -L \
            -X POST \
            -H "Authorization: Bearer ${{ env.GH_TOKEN }}" \
            https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runners/registration-token)

          echo "REGISTRATION_TOKEN=$(echo $RESPONSE | jq -r .token)" >> $GITHUB_ENV

      - name: SSH into EC2 Instance and Register Runner
        env:
          REGISTRATION_TOKEN: ${{ env.REGISTRATION_TOKEN }}
        run: |
          sudo apt-get update -y
          sudo apt-get install -y libicu-dev
          ssh -o StrictHostKeyChecking=no -i ${{ secrets.AWS_KEY_NAME }}.pem ubuntu@${{ env.EC2_PUBLIC_IP }} << EOF
            mkdir actions-runner && cd actions-runner
            curl -o actions-runner-linux-x64-2.317.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.317.0/actions-runner-linux-x64-2.317.0.tar.gz
            tar xzf ./actions-runner-linux-x64-2.317.0.tar.gz

            ./config.sh --url https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }} --token $REGISTRATION_TOKEN --unattended --labels self-hosted,linux,aws
            nohup ./run.sh > nohup.out 2> nohup.err < /dev/null &
          EOF

  verify-dashboards-alerts:
    name: Verify Dashboards and Alerts OK
    needs: deploy-register-self-runner
    runs-on: self-hosted
    defaults: 
      run:
        shell: bash -ieo pipefail {0}
    steps:
      - uses: actions/checkout@v2

      - name: Run Quickstart
        run: |
          sudo chown $(whoami) .
          kind delete clusters kuadrant-local
          kind delete clusters kuadrant-local

          export ISTIO_INSTALL_SAIL=true

          cat << 'EOF' > automate_setup.expect
          #!/usr/bin/expect -f
          set timeout -1
          spawn bash hack/quickstart-setup.sh
          expect "Are you ready to begin? (y/n)"
          send "y\r"
          expect "Do you want to set up a DNS provider for use with Kuadrant's DNSPolicy API? (y/n)"
          send "n\r"
          expect "Thank you for using Kuadrant! If you have any questions or feedback, please reach out to our community."
          EOF
          chmod +x automate_setup.expect
          ./automate_setup.expect

      - name: Port forward grafana and check if contains dashboards.
        run: |
          # Port forward Grafana
          kubectl -n monitoring wait --for=condition=available deployment grafana --timeout=600s
          kubectl -n monitoring port-forward service/grafana 3000:3000 &
          grafana_process_id=$!
          echo "Successfully port forwarded Grafana service."

          sleep 1

          # Make API Call and save response to variable.
          grafana_api_call=$(curl -u admin:admin http://127.0.0.1:3000/api/search)

          # Compare the content in json file with field containing dashboard names

          app_developer=$(jq -r '.panels[1].title' examples/dashboards/app_developer.json)
          business_user=$(jq -r '.panels[1].title' examples/dashboards/business_user.json)
          platform_engineer=$(jq -r '.panels[1].title' examples/dashboards/platform_engineer.json)

          declare -a missing_dashboards=()

          if [[ "$grafana_api_call" != *"$app_developer"* ]]; then
            echo "Grafana does not have $app_developer dashboard."
            missing_dashboards+=("$app_developer")
          fi
          if [[ "$grafana_api_call" != *"$business_user"* ]]; then
            echo "Grafana does not have $business_user dashboard."
            missing_dashboards+=("$business_user")
          fi
          if [[ "$grafana_api_call" != *"$platform_engineer"* ]]; then
            echo "Grafana does not have $platform_engineer dashboard."
            missing_dashboards+=("$platform_engineer")
          fi

          if [[ ${#missing_dashboards[@]} -gt 0 ]]; then
            echo "Grafana is missing the following dashboards:"
            printf '%s\n' "${missing_dashboards[@]}"
            echo "Exiting..."
            exit 1
          fi

          echo "Grafana contains dashboards $app_developer, $business_user and $platform_engineer. Continuing to Prometheus..."

          # Close Grafana port-forward.
          kill $grafana_process_id
          echo "Stoppped port forwarding Grafana."

      - name: Port forward Prometheus and check if contains alert rules.
        run: |
          kubectl -n monitoring wait --for=condition=ready pod prometheus-k8s-0 --timeout=600s
          # Port forward Prometheus
          kubectl -n monitoring port-forward service/prometheus-k8s 9090:9090 &
          prometheus_process_id=$!
          echo "Successfully port forwarded Prometheus service."

          sleep 1

          # Make API Call and save response to variable
          prometheus_api_call=$(curl http://localhost:9090/api/v1/rules)

          # Compare the content in json file with field containing dashboard names.

          readarray -t prometheusrules_policies_missing_alerts < <(yq e '.spec.groups[].rules[].alert' examples/alerts/prometheusrules_policies_missing.yaml)
          readarray -t slo_availability_alerts < <(yq e '.spec.groups[].rules[].alert' examples/alerts/slo-availability.yaml)
          readarray -t slo_latency_alerts < <(yq e '.spec.groups[].rules[].alert' examples/alerts/slo-latency.yaml)

          combined_alerts=("${prometheusrules_policies_missing_alerts[@]}" "${slo_availability_alerts[@]}" "${slo_latency_alerts[@]}")

          declare -a missing_alerts=()

          for alert in "${combined_alerts[@]}"; do
            if [[ "$prometheus_api_call" != *"$alert"* && "$alert" != "null" ]]; then
              echo "Prometheus does not have $alert rule."
              missing_alerts+=("$alert")
            fi
          done

          if [[ ${#missing_alerts[@]} -gt 0 ]]; then
            echo "Prometheus is missing the following alerts:"
            printf '%s\n' "${missing_alerts[@]}"
            echo "Exiting..."
            exit 1
          fi

          echo "Prometheus has all alert rules."

          # Close Prometheus port-forward
          kill $prometheus_process_id
          echo "Stopped port forwarding Prometheus."

  deregister-runner:
    runs-on: ubuntu-latest
    needs: verify-dashboards-alerts
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - uses: hashicorp/setup-terraform@v3

      - name: Initialize Terraform Environment
        run: |
          terraform init

      - name: Download statefile to teardown resources
        uses: actions/download-artifact@v4
        with:
          name: terraform-tfstate
      
      - name: Create PEM file
        run: |
          echo "${{ secrets.AWS_PEM_KEY }}" > ${{ secrets.AWS_KEY_NAME }}.pem
          chmod 600 ${{ secrets.AWS_KEY_NAME }}.pem

      - name: Generate a token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Generate Remove Token
        env:
         GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        id: remove_token
        run: |
          REPO_OWNER=${{ github.repository_owner }}
          REPO_NAME=${{ github.event.repository.name }}

          RUNNER_ID=$(curl -H "Authorization: Bearer ${{ env.GH_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runners | jq '.runners[] | select(.name=="self-hosted") | .id')

          curl -X DELETE -H "Authorization: Bearer ${{ env.GH_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runners/$RUNNER_ID

      - name: Terraform Destroy
        run: terraform destroy -auto-approve -var=aws_access_key=${{ secrets.AWS_ACCESS_KEY_ID }} -var=aws_secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }} -var=aws_key_name=${{ secrets.AWS_KEY_NAME }}
