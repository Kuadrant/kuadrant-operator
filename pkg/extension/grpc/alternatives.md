# What is this
This doc describes the approach we took to the variables/types definitions in CEL and alternatives that _might_ be feasible at some point.

We use go structs defined in `kuadrant-operator/api/v1` and in `kubernetes-sigs/gateway-api/apis/v1` and based on them build our CRDs. To use those types in the CEL, they must implement the `proto.Message` interface. Or the types must be defined as `json` structure.

# The approach we took
The most straightforward approach. The types are getting created from `.proto` files that mirror the structure of the corresponding go struct. For example, in `common.proto` we define a `Metadata` message that represents a combination of `metav1.TypeMeta` and `metav1.ObjectMeta`.

The `.proto` files are created manually, and we select fields and data structures from go structs that would serve our current use case the best without creating redundant complexity. That said, the process is more opinion and preference than anything else.

Once `.proto` is defined, the `protoc` compiler is used in combination with a few plugins for `go`. There is a `generate_proto.sh` script that takes as an argument a version folder name and generates into the indicated folder `*.pb.go` files. It is up to us to later on create a conversion logic between types from `.pb.go` and `../api/...` where it is needed.

It is worth noticing that imported packages are also located in the `vX.Y.Z` folder. It is not "required" but keeps generated files independent of a version of the package on a specific machine.

There are disadvantages to this:
* The need to maintain `.proto` files manually
* Two `go` types that represent the same data structure but are different. Also, the "different" meant that one of the types has less information. Meaning that `gatewayapi.Gateway{}` into `extpb.Gateway{}` into `gatewayapi.Gateway{}` will cause a loss of information.
* Changes to the API are not "detected" unless what was changed is covered by the CEL-related test.
* We have two "sources of truth"

# The alternatives
Below you will find alternatives initially considered not feasible. The preference was given to the manual creation of the `.proto` files.

## Autogenerated `.pb.go`
Instead of "translating" go struct into the `.proto` and then again into the go struct, we could just "slap" an interface onto existing types. This is not common as usually the `.proto` file is used to drive go structs or CRDs. There are two tools that solve this problem.

### Proteus
This is exactly the [tool](https://github.com/src-d/proteus) we would need. Unfortunately, the repository was abandoned in 2020.
The tool itself is very opinionated about the environment it is run on. It assumes the "old" file structure on `GOPATH` and is not cooperating with tools that manage GO version (GVM, for example).
It also needs a specific location of the `protoc` and its plugins to work. For all of this to work, one would need to rewrite and maintain the logic of the CLI.
Once rewritten, it still needs a **very** specific location of packages you intend to convert in `.pb.go`. Changing this aspect will result in most of the code of the CLI being modified.

### go-to-protobuf
There is a tool Kubernetes uses to generate Protobuf definitions from the go structs. It is written using their [codegen](https://github.com/kubernetes/code-generator/tree/master). And the source code of the generator we want is [here](https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/code-generator/cmd/go-to-protobuf). There is also a [blog post](https://www.redhat.com/en/blog/kubernetes-deep-dive-code-generation-customresources) on the RedHat portal about code generator from there. It, however, does not include the `go-to-protobuf`. The issue there is that this generator is intended to be used **exclusively** internally by Kubernetes and also has a lot of opinions about how it is used and in what environment. Naturally, there are few examples or guides. There is a Slack [thread](https://kubernetes.slack.com/archives/C0EG7JC6T/p1745846263805269) with Kubernetes people about the usage of this generator - that is a close as one can get to the docs about this tool. And here is an [example](https://github.com/search?q=repo%3Akubernetes%2Fkubernetes+protoc-gen-gogo&type=code) of the generator being used. It will look for the `// +k8s:protobuf-gen=package` [comments](https://github.com/search?q=repo%3Akubernetes%2Fkubernetes+k8s%3Aproto&type=code&p=1) and should produce the output. However, it is meant to be used alongside other generators and is built to only consider Kubernetes types. There was around it, but there is no guarantee that those ways will remain present as the tool changes to meet the needs of Kubernetes.

## Json
We can consume a structural schema to tell CEL about the structure of the data and allow it to be parsed. [Here](https://kubernetes.io/blog/2019/06/19/kubernetes-1-15-release-announcement/#:~:text=In%20this%20direction%2C%20we%20have,beta:%20CustomResourceDefinition%20Webhook%20Conversion) is more about what structural schema is, and [here](https://swagger.io/specification/) is a definition of the ones we have in our CRDs. We could use `UnstructuredToVal` or `TypedToVal` [from](https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apiserver/pkg/cel/common) Kubernetes to convert a schema plus type into a `ref.Value` struct that CEL will understand. [Here](https://github.com/kubernetes/kubernetes/blob/cf6cc0f5d7a9c15e7843fb46ceb77db10550d08f/staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/schema/structural.go) is a definition of the `Structural` type. We could [convert](https://github.com/search?q=repo%3Akubernetes%2Fkubernetes+JSONSchemaProps+&type=code&p=2) a JSON schema into this type. And if consuming CRDs is not an option, we can use tools ([example](https://github.com/invopop/jsonschema/tree/main)) to generate schemas from go types that later could be fed into the converter. Or we could just [build](https://github.com/search?q=repo%3Akubernetes%2Fkubernetes+OpenAPIV3Schema%3A+%26apiextensionsv1.JSONSchemaProps%7B+&type=code) those schemas in-code, but that looks like an even worse option compared to manual `.proto` files.

We didn't build our controllers around OpenAPI schemas, and this tool seems to be meant for [such controllers](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiextensions-apiserver/pkg/controller/openapiv3/controller.go). And the reasoning behind it is the loss of types, as JSON types are a bit limited (among other JSON issues). This made it not desirable to use this implementation. But it is still an option: it would just use [this](https://github.com/google/cel-spec/blob/master/doc/langdef.md#json-data-conversion) part of the CEL instead of Protobuf.  










